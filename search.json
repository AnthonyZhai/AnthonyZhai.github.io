[{"title":"修改我的博客","path":"/2024/05/ef9d6b234113.html","content":"你好我需要修改我的博客","tags":["每日一题"]},{"title":"洛谷 P1118","path":"/2024/05/1c8ce4d28836.html","content":"洛谷 P1118 Backward Digit Sums G/Shttps://www.luogu.com.cn/problem/P1118https://www.luogu.com.cn/problem/P1118 壹、问题描述写出一个 $1 \\sim n$ 的序列 $a_i$ ，然后每次将相邻两个数相加，构成新的序列，再对新序列进行这样的操作，显然每次构成的序列逗比上一次的序列长度少1，直到只剩下一个数字为止。下面是一个例子： 12343 1 2 44 3 67 916 现在倒着玩这个游戏，如果知道 $n$ ，知道最后得到的数字 $sum$ ，请求出最初序列 $a_i$ ，即为 $1 \\sim n$ 的一个排列。若答案有多种可能，则输出字典序最小的那个。 输入格式输入两个整数 $n$ 和 $sum$，$n \\leq 12, sum \\leq 12345$。 输出格式输出字典序最小的那个序列。 输入样例4 16 输出样例3 1 2 4 贰、题目分析回溯算法很明显，这是一个回溯算法，我们需要找到$1 \\sim n$ 的一个全排列满足题目的要求。 全排列的生成可以使用回溯算法生成。 杨辉三角但是如果计算相邻元素之和直到剩余一个元素为止呢？ 先来看看以下公式推导，开始前假设我们有5个数字 $a，b，c，d，e$。 a\\quad\\quad\\quad\\quad b\\quad\\quad\\quad\\quad c\\quad\\quad\\quad\\quad d\\quad\\quad\\quad\\quad e \\\\ a+b\\quad\\quad\\quad b+c\\quad\\quad\\quad c+d\\quad\\quad\\quad d+e \\\\ a+2b+c\\quad b+2c+d\\quad c+2d+e \\\\ a+3b+3c+d\\quad b+3c+3d+e \\\\ a+4b+6c+4d+e如果我们只有3个数字$a，b，c$。 a\\quad\\quad b\\quad\\quad c\\\\ a+b\\quad b+c\\\\ a+2b+c可以看出：1）3个数字用题目的规则相加之后，最后得到的数字系数为杨辉三角中的第3行：1 2 12）5个数字用题目的规则相加之后，最后得到的数字系数为杨辉三角中的第5行：1 4 6 4 1 因此，我们可以提前根据输入的 $n$ 计算出杨辉三角的第 $n$ 行，这些值就构成全排列前面的系数数组 $f_i$。 在回溯算法过程中，每得到一组全排列，我们就可以计算出 $sum = \\sum_{i=1}^n a_i * f_i$。 剪枝我们可以在每次回溯时，判断当前的 $sum$ 是否大于 $sum$，如果大于 $sum$，则直接跳过这一轮回溯。例如，当 $n = 9$ 时，计算到排列 ${2, 1, 3, 4, 5, 6, 7, 8, 9}$ 时，若前5个元素 ${2, 1, 3, 4, 5}$ 的和已经大于 $sum$ ，那么后面的全排列都可以跳过，下一个排列应该从 ${2, 1, 3, 4, 6, 5, 7, 8, 9}$ 开始。 叁、代码实现回溯框架因为本题是让找到字典序最小的一个全排列，即在诸多满足要求的全排列中返回其中字典序最小的一个，所以在声明DFS函数时，其返回值是bool。这意味着一旦找到第一个满足要求的全排列则返回，不再继续寻找下一个。1234567891011121314bool DFS(int n, int s)&#123; // 在数组的n位置进行全排列 if(s &gt; sum) return false; if(s == sum)&#123; //打印满足要求的数组a return true; &#125; for(int i = 1; i &lt;= n; i++)&#123; //在n位置进行全排列 a[n] = i; if(DFS(n+1, 新计算出的sum))&#123; return true; &#125; &#125;&#125; 计算杨辉三角杨辉三角，是二项式系数在三角形中的一种几何排列，中国南宋数学家杨辉1261年所著的《详解九章算法》一书中出现。点开查看更多杨辉三角的内容杨辉三角-百度百科简而言之，杨辉三角就是：1）每一行第一个数字和最后一个数字都是1。2）剩余数字等于上一行相邻两个数字之和。12345678910111213141516const int maxn = 12345 + 5;int f[2][maxn]; //使用滚动数组计算杨辉三角...//生成杨辉三角for(int i=1; i&lt;=n; i++)&#123; //用数组的第二行f[1][x]保存新计算出的杨辉三角 f[1][1] = 1; for(int j=2; j&lt;i; j++)&#123; f[1][j] = f[0][j-1] + f[0][j]; &#125; f[1][i] = 1; //将第二行的结果复制到第一行，以供新一轮的计算 for(int j=1; j&lt;=i; j++)&#123; f[0][j] = f[1][j]; &#125;&#125; 剪枝使用数组visited来记录当前排列有没有生成过！有则跳过，没有则继续生成。123456789101112131415const int maxn = 12345 + 5;int vistied[maxn];bool DFS(int p, int s)&#123; ... ... ... ... for(int i=1; i&lt;=n; i++)&#123; if(!vistied[i])&#123; vistied[i] = 1; ... ... ... ... vistied[i] = 0; &#125; &#125;&#125;在选择数字 $1$ 生成搜索树的第1个分支后，那么它的分支是不能继续使用数字 $1$ ，而应该在剩余的数字中继续做选择。这就是visited数组的作用。 graph TB A((_ _ _)) B((1 _ _)) C((2 _ _)) D((3 _ _)) E((1 2 _)) F((1 3 _)) G((2 1 _)) H((2 3 _)) I((3 1 _)) J((3 2 _)) K((1 2 3)) L((1 3 2)) M((2 1 3)) N((2 3 1)) O((3 1 2)) P((3 2 1)) A----B A----C A----D B----E B----F C----G C----H D----I D----J E----K F----L G----M H----N I----O J----P 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;const int maxn = 12345 + 5;int n, sum; int f[2][maxn], a[maxn];int vistied[maxn];bool DFS(int p, int s)&#123; if(s&gt;sum)&#123; return false; &#125; if(s==sum &amp;&amp; p &gt; n)&#123; for(int i=1; i&lt;=n; i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; return true; &#125; for(int i=1; i&lt;=n; i++)&#123; if(!vistied[i])&#123; a[p] = i; vistied[i] = 1; int add = a[p] * f[0][p]; s += add; if(DFS(p+1, s)) return true; s -= add; vistied[i] = 0; &#125; &#125; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;sum; //生成杨辉三角 for(int i=1; i&lt;=n; i++)&#123; f[1][1] = 1; for(int j=2; j&lt;i; j++)&#123; f[1][j] = f[0][j-1] + f[0][j]; &#125; f[1][i] = 1; for(int j=1; j&lt;=i; j++)&#123; f[0][j] = f[1][j]; &#125; &#125; DFS(1, 0);&#125;","tags":["每日一题"],"categories":["信奥"]},{"title":"POJ 3278","path":"/2024/05/a8002aaa12f3.html","content":"POJ 3278 Catch That Cowhttp://poj.org/problem?id=3278http://poj.org/problem?id=3278 壹、问题描述在一条直线上，奶牛在 $K$ 位置，农夫在 $N$ 位置。农夫想抓住牛，他有3种移动方法：如他在 $X$ 位置，他每次可以移动到 $X-1$，$X+1$，$2X$ 的位置。问农夫最少要移动多少次才能从 $N$ 位置到达 $K$ 位置？ 输入格式输入两个整数 $N$ 和 $K$，$ 0 &lt;= N, K &lt;= 100000$。 输出格式最少移动次数。 输入样例5 17 输出样例4 贰、题目分析农夫在 $X$ 位置都有3种选择，则该农夫找奶牛的过程就是一棵搜索树，而且是一棵三叉树。以农夫在位置5，奶牛在位置17为例，这棵搜索树的部分结构如下： 图表可以左右滚动查看哦。 graph TB A((5)) B((6)) C((4)) D((10)) E((5)) F((7)) G((12)) H((3)) I((5)) J((8)) K((9)) L((11)) M((20)) N((4)) O((6)) P((10)) Q((6)) R((8)) S((14)) T((8)) U((10)) V((18)) W((10)) X((12)) Y((22)) Z((17)) AA((19)) AB((36)) A---B A---C A---D B---|剪枝|E B---F B---G C---H C---I C---J D---K D---L D---M E---N E---O E---P F---Q F---R F---S K---T K---U K---V L---W L---X L---Y V---Z V---AA V---AB 问题转换那么，其实求农夫到达奶牛的最小移动次数，就可以转换为求这棵搜索树的满足要求的最小深度。因为每次做出一次选择，搜索树就会多出一层，而我们现在需要找到满足要求的结点（在这个例子中，是要找结点17）所在的最小层数-1，即满足要求的结点的最小深度。 有关树的深度、高度、层次深度：对于任意节点 $n$，$n$ 的深度为从根到 $n$ 的唯一路径长，根的深度为0。高度：对于任意节点 $n$，$n$ 的高度为从 $n$ 到一片树叶的最长路径长，所有树叶的高度为0。结点的层次：规定根结点在1层，其它任一结点的层数是其父结点的层数加1。树的深度：树中所有结点中的最大层次是这棵树的深度。 因此，可以使用BFS搜索来求解。 记忆化搜索其次，可以看到在上图中做出 $N+1$ 的选择到达第2层的结点6后，如果此时做出 $N-1$ 的选择到达第3层的结点5，又会和根结点是一样的。 因此，还可以使用记忆化搜索的策略来达到去重的目的，其实也就是剪枝的操作。 有关剪枝、记忆化搜索OI Wiki 额外处理如果开始时，农夫所在位置 $N$ 大于等于奶牛所在位置 $K$，那么此时农夫只能选择每次回退一步（$N-1$）。这种情况是不用放入BFS里面的。 叁、代码实现自定义结构体由于需要计算最小深度，因此需要自定义结构体 node，里面包含了 N 和 step 两个变量，分别代表当前结点代表的农夫位置和移动次数。1234struct node&#123; int N; int step;&#125; BFS的框架BFS搜索的代码非常常用，希望可以记忆。 12345678910111213141516#include &lt;queue&gt;...queue&lt;状态&gt; q;void BFS(开始状态， 目标状态)&#123; q.push(开始状态); while(!q.empty())&#123; 获取当前状态 if(当前状态 == 目标状态)&#123; 打印结果并返回 &#125; 作出给定的选择并更新状态 将更新后的状态压入队列 &#125;&#125; 应用剪枝策略后的框架经过之前的分析，显然我们的BFS框架需要应用剪枝策略来优化速度，这里用到的剪枝是记忆化搜索。 1234567891011121314151617181920#include &lt;queue&gt;...queue&lt;状态&gt; q;set&lt;状态&gt; s;void BFS(开始状态， 目标状态)&#123; q.push(开始状态); s.insert(开始状态); //将当前结点（状态）标记为已经被访问过 while(!q.empty())&#123; 获取当前状态 if(当前状态 == 目标状态)&#123; 打印结果并返回 &#125; 作出给定的选择并更新状态 if(更新后的状态没有被访问过)&#123; 将更新后的状态压入队列 s.insert(更新后的状态); //将更新后的状态标记为已经访问过 &#125; &#125;&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;queue&gt;#include &lt;set&gt;using namespace std;struct node&#123; //状态 int N; //当前农夫所在位置 int step; //达到当前位置的移动次数&#125;queue&lt;node&gt; q; //存储状态的队列set&lt;int&gt; visited; //这里不需要完整的状态，只需要其位置，就能做到去重的目的void BFS(node start, int K)&#123; q.push(start); visited.insert(start.N); //根结点的深度为0 while(!q.empty())&#123; node now = q.front(); q.pop(); int N = now.N, step = now.step; if(N == K)&#123; cout &lt;&lt; now.step &lt;&lt; endl; return; &#125; int next[3] = &#123;N-1, N+1, N*2&#125;; for(int i=0; i&lt;3; i++)&#123; int nextN = next[i]; //依次作出三种选择 if(visited.count(nextN) == 0)&#123; //如果没有访问过 q.push(&#123;nextN, step+1&#125;); visited.insert(nextN); //标记已经访问过 &#125; &#125; &#125;&#125;int main()&#123; int N, K; cin &gt;&gt; N &gt;&gt; K; if(N&gt;=K)&#123; cout &lt;&lt; N-K &lt;&lt; endl; &#125;else&#123; BFS(&#123;N, 0&#125;, K); &#125; return 0;&#125; 肆、优化如果将上面的代码提交之后，你就会惊奇地发现 Time Limit Exceeded 这是因为，我们使用了queue和set的缘故，STL库的使用会拖慢代码的执行速度。 同时，也因为使用了自定义结构体，而且在queue中存储，这就涉及到赋值的问题。 因此，自定义结构体node需要新增以下构造函数才不会报错。123456struct node&#123; node(): N(0), step(0)&#123;&#125; node(int n, int s): N(n), step(s)&#123;&#125; int N; int step;&#125;","tags":["每日一题"],"categories":["信奥"]}]